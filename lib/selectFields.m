function [targetVars, targetVarList, status] = selectFields(varList, structData, isUserDefined)% ##### varList%% A cell string of size 1 x n or a single string that specifies n variables or s% single variable in every data files to be processed. The string could be a% literal string specifying the variable name, a glob pattern consisting one or% more asterisks, or a regular expression. Use `'1'` to specify ALL the variables% and `'eye()'` or `'file()'` to specify the variable which has the same name with% the data file it was stored in.%% Use a cell string of size m x n to respectively specify the variables to be% processed for every single data files. m should be the same with the number of% data files to be processed. For example:% ```matlab% % set the value of `varList` to one of the values below%% % to process variable `Trials` in all the data files% 'Trials'%% % to process variables `Pre` and `Post` in all the data files% {'Pre', 'Post'}%% % to process fields `Pre` and `Post` of variable `data` in all the data files% {'data.Pre', 'data.Post'}%% % or 'train*' to process variables `train1`, `train2` etc. in all the data files% {'train*'}%% % process ALL the variables in the first mat file, and process the variable that% % shares name with the second data file% {'1'; 'eye()'}% ```isDebug = 1;targetVarList = {};targetVars = {};if exist('isUserDefined', 'var') == 1 && isUserDefined  % target value provided as user input  % no need to filter out from the data files  targetVarList = cellstr('isUserDefined');  targetVars = varList;  returnelse  % we got a lot of parsing to do...  % first get the variable names out of varList, then get the values  % decoded varList cell string  % can be used directly for dynamic structure inexing: s.(fieldName)  if iscellstr(varList)    % parse each element separately    for iVar = 1 : numel(varList)      if ischar(varList{iVar})        [targetVarList{iVar} status] = parseVarString(varList{iVar}, structData);      end    end    newTargetVarList = {};    for iVarlistPerFile = 1:size(varList, 1)      if size(varList(iVarlistPerFile, :), 2) > 1        newTargetVarList{iVarlistPerFile} = cellfun(@(x) x{:}, targetVarList, 'UniformOutput', 0);      end    end    if ~isempty(newTargetVarList); targetVarList = newTargetVarList; end  elseif ischar(varList)    % function() or pattern?    [targetVarList{1} status] = parseVarString(varList, structData);  end % cellstr or a single string  % Hurrah! No more enigmas now!  for iOnePerFile = 1 : numel(targetVarList)    for iVar = 1 : numel(targetVarList{iOnePerFile})      try        %targetVars{iVar} = structData.(targetVarList{iVar});        % NOTE: Allow for structure indexing        targetVars{iOnePerFile}{iVar} = recursiveGetFields(['structData.' targetVarList{iOnePerFile}{iVar}]);      catch        error('selectFields:VariableNotFound',...          'I knew I could catch one someday!');      end    end  endend % isUserDefinedend % functionfunction [matchedVarList, status] = parseVarString(requestedVar, wrkspc)status.succeed = 0;% requestedVar is an encoded string% return the decoded cell stringallVariables = fieldnames(wrkspc);% file__Name__ was not part of original dataallVariables(strcmp(allVariables, 'file__Name__')) = [];if any(strcmp(requestedVar, {'file()', 'eye()'}))  % use the file name  status.isFromFileName = 1;  % use it as the variable name value provider  requestedVar = cellstr(regexprep(wrkspc.file__Name__, '\.mat$', ''));elseif strcmp(requestedVar, '1')  % use all variables  status.isAllVariables = 1;  requestedVar = allVariables;elseif ~isempty(regexp(requestedVar, '^s/.*/$', 'once'))  % this is a regexp  status.isRegexp = 1;  requestedVar = requestedVar(3:end-1); % strip out s//  matchstart = regexp(allVariables, requestedVar);  requestedVar = allVariables(~cellfun(@isempty, matchstart));elseif ~isempty(regexp(requestedVar, '\*', 'once'))  % found a possible glob pattern  status.isGlob = 1;  % a simple sanity check  if isempty(regexp(requestedVar, '[^\w\.\*]'))    % we are clean    % turn into a regex    requestedVar = regexprep(requestedVar, '\.', '\\.');    requestedVar = regexprep(requestedVar, '\*', '.*');    % process this regex    matchstart = regexp(allVariables, requestedVar);    requestedVar = allVariables(~cellfun(@isempty, matchstart));  else    warning('selectFields:invalidPattern', ...      'Possible glob pattern `%s` found, but is invalid!', requestedVar);  endelseif any(strcmp(allVariables, regexprep(requestedVar, '^([a-zA-Z]+\w*)\..*', '$1')))  % literal  requestedVar = cellstr(requestedVar);else  % what the hell!  status.isUnknownEnigma = 1;  warning('selectFields:UnknownVeriableSpecifier',...    'Found no variable that matches varList.');  if isDebug; keyboard; endendmatchedVarList = requestedVar;end